# Create an updated HTML file with draggable IDEF0 boxes, edge handles, and SVG connectors.
html_content = r"""<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>IDEF0 Diagram with Handles & Connectors</title>
  <style>
    /* --- Page Layout --- */
    html, body {
      height: 100%;
      margin: 0;
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
      background: #e9ecef;
    }
    .page {
      display: grid;
      grid-template-rows: auto 1fr auto;
      height: 100%;
    }
    header, footer {
      background: #fff;
      border-bottom: 1px solid #ccc;
      padding: 8px 12px;
    }
    footer { border-top: 1px solid #ccc; border-bottom: none; }
    /* --- Canvas --- */
    .canvas {
      position: relative;
      background: #f8fbff;
      margin: 8px;
      border: 1px solid #cbd5e1;
      border-radius: 8px;
      overflow: hidden;
    }
    /* SVG overlay sits above background but below nodes */
    svg.connections {
      position: absolute;
      inset: 0;
      pointer-events: none; /* let mouse go through to nodes */
    }
    /* --- Function Node --- */
    .function {
      position: absolute;
      width: 220px;
      height: 120px;
      border: 2px solid #1f2937;
      background: #ffffff;
      border-radius: 4px;
      box-shadow: 0 2px 6px rgba(0,0,0,0.08);
      display: flex;
      align-items: center;
      justify-content: center;
      text-align: center;
      padding: 10px 24px 18px 24px; /* space for handles and number */
      box-sizing: border-box;
      user-select: none;
      cursor: move;
    }
    .function .function-name {
      font-weight: 700;
      font-size: 14px;
      line-height: 1.2;
    }
    .function .function-number {
      position: absolute;
      right: 6px;
      bottom: 4px;
      font-size: 12px;
      color: #111827;
    }
    /* --- Handles (anchors) --- */
    .handle {
      position: absolute;
      width: 12px;
      height: 12px;
      border: 2px solid #1f2937;
      background: #ffffff;
      border-radius: 50%;
      box-sizing: border-box;
      z-index: 2;
      cursor: crosshair;
    }
    /* Positions per IDEF0 ICOM semantics */
    .handle-left   { left: -6px;  top: 50%; transform: translate(-50%, -50%); }
    .handle-right  { right: -6px; top: 50%; transform: translate(50%, -50%); }
    .handle-top    { top: -6px;   left: 50%; transform: translate(-50%, -50%); }
    .handle-bottom { bottom: -6px;left: 50%; transform: translate(-50%, 50%); }
    /* Role color ring (subtle) */
    .handle[data-role="input"]     { box-shadow: 0 0 0 2px rgba(59,130,246,0.25); }   /* left */
    .handle[data-role="control"]   { box-shadow: 0 0 0 2px rgba(16,185,129,0.25); }   /* top */
    .handle[data-role="output"]    { box-shadow: 0 0 0 2px rgba(234,179,8,0.25);  }   /* right */
    .handle[data-role="mechanism"] { box-shadow: 0 0 0 2px rgba(239,68,68,0.25);  }   /* bottom */
    /* Connector styling */
    .connector {
      stroke: #111827;
      stroke-width: 2;
      fill: none;
    }
    .connector[data-kind="control"]   { stroke-dasharray: 6 4; }
    .connector[data-kind="mechanism"] { stroke-dasharray: 2 4; }
    /* Selection feedback */
    .handle.active {
      background: #111827;
    }
    /* Mini toolbar */
    .toolbar {
      display: flex;
      gap: 8px;
      align-items: center;
      font-size: 12px;
    }
    button {
      padding: 6px 10px;
      border: 1px solid #94a3b8;
      background: #fff;
      border-radius: 6px;
      cursor: pointer;
    }
    button:hover { background: #f1f5f9; }
    .hint {
      color: #334155;
      font-size: 12px;
      margin-left: 8px;
    }
  </style>
</head>
<body>
  <div class="page">
    <header>
      <div class="toolbar">
        <button id="addBox">Add Function</button>
        <button id="clearEdges">Clear Connectors</button>
        <span class="hint">Tip: Click a handle on Box A, then a compatible handle on Box B to create a connector. Drag boxes to see lines follow.</span>
      </div>
    </header>

    <main class="canvas" id="canvas" aria-label="IDEF0 canvas">
      <!-- SVG for connectors -->
      <svg class="connections" id="connSvg"></svg>

      <!-- Example nodes -->
      <div class="function" id="fn-1" style="left: 120px; top: 120px;">
        <div class="handle handle-top"    data-role="control"   data-handle="top"></div>
        <div class="handle handle-left"   data-role="input"     data-handle="left"></div>
        <div class="handle handle-right"  data-role="output"    data-handle="right"></div>
        <div class="handle handle-bottom" data-role="mechanism" data-handle="bottom"></div>
        <div class="function-name" contenteditable="true">PLAN NEW INFORMATION PROGRAM</div>
        <div class="function-number">1</div>
      </div>

      <div class="function" id="fn-2" style="left: 480px; top: 260px;">
        <div class="handle handle-top"    data-role="control"   data-handle="top"></div>
        <div class="handle handle-left"   data-role="input"     data-handle="left"></div>
        <div class="handle handle-right"  data-role="output"    data-handle="right"></div>
        <div class="handle handle-bottom" data-role="mechanism" data-handle="bottom"></div>
        <div class="function-name" contenteditable="true">DELIVER PRODUCTS</div>
        <div class="function-number">2</div>
      </div>
    </main>

    <footer>
      Node: FHOA/A0 &nbsp;&middot;&nbsp; Title: Evolve System &nbsp;&middot;&nbsp; Status: WORKING
    </footer>
  </div>

  <script>
    /* ========= Utilities ========= */
    const canvas = document.getElementById('canvas');
    const connSvg = document.getElementById('connSvg');

    function qp(sel, root=document){ return root.querySelector(sel); }
    function qpa(sel, root=document){ return Array.from(root.querySelectorAll(sel)); }

    function getHandlePoint(handleEl) {
      // return page-space center of the handle
      const r = handleEl.getBoundingClientRect();
      return { x: r.left + r.width/2 + window.scrollX, y: r.top + r.height/2 + window.scrollY };
    }

    function getCanvasPointFromPage(p) {
      const cr = canvas.getBoundingClientRect();
      return { x: p.x - cr.left - window.scrollX, y: p.y - cr.top - window.scrollY };
    }

    function cubicPath(p0, p1, side0, side1) {
      // Create a smooth cubic Bezier path between p0 and p1 based on exit/entry sides
      const dx = Math.max(40, Math.abs(p0.x - p1.x) / 2);
      const dy = Math.max(40, Math.abs(p0.y - p1.y) / 2);

      let c1 = {x: p0.x, y: p0.y};
      let c2 = {x: p1.x, y: p1.y};

      if (side0 === 'right') c1.x += dx;
      if (side0 === 'left')  c1.x -= dx;
      if (side0 === 'top')   c1.y -= dy;
      if (side0 === 'bottom')c1.y += dy;

      if (side1 === 'right') c2.x += dx;
      if (side1 === 'left')  c2.x -= dx;
      if (side1 === 'top')   c2.y -= dy;
      if (side1 === 'bottom')c2.y += dy;

      return `M ${p0.x},${p0.y} C ${c1.x},${c1.y} ${c2.x},${c2.y} ${p1.x},${p1.y}`;
    }

    /* ========= Connectors Model ========= */
    const connectors = []; // array of {id, a:{nodeId, handleSide, role}, b:{...}, pathEl}

    function makeConnectorId() {
      return 'edge-' + Math.random().toString(36).slice(2, 9);
    }

    function createConnector(aHandle, bHandle) {
      const aRole = aHandle.dataset.role;
      const bRole = bHandle.dataset.role;

      // Basic IDEF0 direction sanity: allow output->input/control/mechanism; input/control/mechanism can flow to ???
      // We'll enforce the classic case: from 'output' to 'input' OR 'control' OR 'mechanism'
      const valid =
        (aRole === 'output'   && (bRole === 'input' || bRole === 'control' || bRole === 'mechanism')) ||
        (aRole === 'control'  && bRole === 'input') || // e.g., control feeding into a function's left (if someone wants that style)
        (aRole === 'input'    && bRole === 'output') || // allow reversed draw; we normalize direction below
        (aRole === 'mechanism'&& bRole === 'input');

      // Normalize so the semantic "kind" is the role of the source handle when it is one of output/control/mechanism
      let source = aHandle, target = bHandle;
      if (!(aRole === 'output' || aRole === 'control' || aRole === 'mechanism')) {
        // swap to prefer source from [output|control|mechanism]
        [source, target] = [bHandle, aHandle];
      }

      const kind = source.dataset.role; // output | control | mechanism (usually)
      if (!valid) {
        console.warn('Incompatible handle roles for IDEF0 semantics.');
        return;
      }

      const id = makeConnectorId();
      const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
      path.classList.add('connector');
      path.setAttribute('data-kind', kind);
      path.setAttribute('id', id);
      connSvg.appendChild(path);

      const conn = {
        id,
        a: {
          nodeId: source.closest('.function').id,
          handleSide: source.dataset.handle,
          role: source.dataset.role,
          handleEl: source
        },
        b: {
          nodeId: target.closest('.function').id,
          handleSide: target.dataset.handle,
          role: target.dataset.role,
          handleEl: target
        },
        pathEl: path
      };
      connectors.push(conn);
      updateConnectorPath(conn);
    }

    function updateConnectorPath(conn) {
      const p0 = getCanvasPointFromPage(getHandlePoint(conn.a.handleEl));
      const p1 = getCanvasPointFromPage(getHandlePoint(conn.b.handleEl));
      const d = cubicPath(p0, p1, conn.a.handleSide, conn.b.handleSide);
      conn.pathEl.setAttribute('d', d);
    }

    function refreshAllConnectors() {
      connectors.forEach(updateConnectorPath);
    }

    /* ========= Dragging ========= */
    let drag = null; // {el, startX, startY, origLeft, origTop}
    canvas.addEventListener('mousedown', (e) => {
      const node = e.target.closest('.function');
      if (!node) return;
      // avoid starting a drag when clicking a handle or editing text
      if (e.target.classList.contains('handle') || e.target.isContentEditable) return;
      const rect = node.getBoundingClientRect();
      drag = {
        el: node,
        startX: e.clientX,
        startY: e.clientY,
        origLeft: parseFloat(node.style.left || 0),
        origTop: parseFloat(node.style.top || 0)
      };
      e.preventDefault();
    });

    window.addEventListener('mousemove', (e) => {
      if (!drag) return;
      const dx = e.clientX - drag.startX;
      const dy = e.clientY - drag.startY;
      drag.el.style.left = (drag.origLeft + dx) + 'px';
      drag.el.style.top  = (drag.origTop  + dy) + 'px';
      refreshAllConnectors();
    });

    window.addEventListener('mouseup', () => { drag = null; });

    /* ========= Handle Click-to-Connect ========= */
    let pendingHandle = null;
    canvas.addEventListener('click', (e) => {
      const h = e.target.closest('.handle');
      if (!h) return;

      // Toggle selection
      if (pendingHandle === h) {
        h.classList.remove('active');
        pendingHandle = null;
        return;
      }

      if (!pendingHandle) {
        pendingHandle = h;
        h.classList.add('active');
      } else {
        // second click -> attempt to connect
        if (pendingHandle.closest('.function') !== h.closest('.function')) {
          createConnector(pendingHandle, h);
        }
        pendingHandle.classList.remove('active');
        pendingHandle = null;
      }
      e.stopPropagation();
    });

    // Clicking empty canvas clears pending
    canvas.addEventListener('click', (e) => {
      if (e.target === canvas) {
        if (pendingHandle) pendingHandle.classList.remove('active');
        pendingHandle = null;
      }
    });

    /* ========= Toolbar ========= */
    qp('#clearEdges').addEventListener('click', () => {
      connectors.splice(0).forEach(c => c.pathEl.remove());
    });

    qp('#addBox').addEventListener('click', () => {
      const id = 'fn-' + Math.random().toString(36).slice(2,7);
      const node = document.createElement('div');
      node.className = 'function';
      node.id = id;
      node.style.left = Math.round(120 + Math.random()*360) + 'px';
      node.style.top  = Math.round(80 + Math.random()*280) + 'px';
      node.innerHTML = `
        <div class="handle handle-top"    data-role="control"   data-handle="top"></div>
        <div class="handle handle-left"   data-role="input"     data-handle="left"></div>
        <div class="handle handle-right"  data-role="output"    data-handle="right"></div>
        <div class="handle handle-bottom" data-role="mechanism" data-handle="bottom"></div>
        <div class="function-name" contenteditable="true">NEW FUNCTION</div>
        <div class="function-number">${(Math.floor(Math.random()*6)+1)}</div>
      `;
      canvas.appendChild(node);
    });

    /* ========= Initial Demo Edge ========= */
    window.addEventListener('load', () => {
      // Connect output of fn-1 to input of fn-2
      const a = qp('#fn-1 .handle-right');
      const b = qp('#fn-2 .handle-left');
      createConnector(a, b);
    });

    /* Keep SVG sized to canvas */
    function sizeSvgToCanvas() {
      const cr = canvas.getBoundingClientRect();
      connSvg.setAttribute('width', cr.width);
      connSvg.setAttribute('height', cr.height);
    }
    new ResizeObserver(() => { sizeSvgToCanvas(); refreshAllConnectors(); }).observe(canvas);
    sizeSvgToCanvas();
  </script>
</body>
</html>
"""
with open("/mnt/data/idef0_with_handles.html", "w", encoding="utf-8") as f:
    f.write(html_content)

"/mnt/data/idef0_with_handles.html"
